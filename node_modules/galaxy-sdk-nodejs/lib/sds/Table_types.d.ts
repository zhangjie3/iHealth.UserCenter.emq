//
// Autogenerated by Thrift Compiler (0.9.2)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


/**
 * 数据类型
 */
declare enum DataType {
  'BOOL' = 1,
  'INT8' = 2,
  'INT16' = 3,
  'INT32' = 4,
  'INT64' = 5,
  'FLOAT' = 6,
  'DOUBLE' = 7,
  'STRING' = 8,
  'BINARY' = 9,
  'RAWBINARY' = 10,
  'BOOL_SET' = 100,
  'INT8_SET' = 101,
  'INT16_SET' = 102,
  'INT32_SET' = 103,
  'INT64_SET' = 104,
  'FLOAT_SET' = 105,
  'DOUBLE_SET' = 106,
  'STRING_SET' = 107,
  'BINARY_SET' = 108,
}

/**
 * 操作符类型
 */
declare enum OperatorType {
  'EQUAL' = 1,
  'NOT_EQUAL' = 2,
  'GREATER' = 3,
  'GREATER_OR_EQUAL' = 4,
  'LESS' = 5,
  'LESS_OR_EQUAL' = 6,
}

/**
 * 索引数据一致性类型
 */
declare enum SecondaryIndexConsistencyMode {
  'LAZY' = 0,
  'EAGER' = 1,
  'IMMUTABLE' = 2,
}

/**
 * ACL模板，针对每个应用进行设置，
 * 开发者登录可以访问所拥有的表数据，无需额外设置
 */
declare enum CannedAcl {
  'APP_SECRET_READ' = 1,
  'APP_SECRET_WRITE' = 2,
  'APP_USER_ENTITY_GROUP_READ' = 3,
  'APP_USER_ENTITY_GROUP_WRITE' = 4,
  'APP_USER_READ' = 5,
  'APP_USER_WRITE' = 6,
  'PUBLIC_READ' = 7,
  'PUBLIC_WRITE' = 8,
}

/**
 * 表状态
 */
declare enum TableState {
  'CREATING' = 1,
  'ENABLING' = 2,
  'ENABLED' = 3,
  'DISABLING' = 4,
  'DISABLED' = 5,
  'DELETING' = 6,
  'DELETED' = 7,
  'LAZY_DELETE' = 8,
}

declare enum ScanOp {
  'COUNT' = 0,
  'DELETE' = 1,
  'UPDATE' = 2,
}

declare enum BatchOp {
  'GET' = 1,
  'PUT' = 2,
  'INCREMENT' = 3,
  'REMOVE' = 4,
}
  boolValue: boolean;
  int8Value: any;
  int16Value: number;
  int32Value: number;
  int64Value: number;
  doubleValue: number;
  stringValue: string;
  binaryValue: string;
  boolSetValue: boolean[];
  int8SetValue: any[];
  int16SetValue: number[];
  int32SetValue: number[];
  int64SetValue: number[];
  doubleSetValue: number[];
  stringSetValue: string[];
  binarySetValue: string[];
  nullValue: boolean;

  constructor(args?: { boolValue?: boolean; int8Value?: any; int16Value?: number; int32Value?: number; int64Value?: number; doubleValue?: number; stringValue?: string; binaryValue?: string; boolSetValue?: boolean[]; int8SetValue?: any[]; int16SetValue?: number[]; int32SetValue?: number[]; int64SetValue?: number[]; doubleSetValue?: number[]; stringSetValue?: string[]; binarySetValue?: string[]; nullValue?: boolean; });
}
  type: DataType;
  value: Value;

  constructor(args?: { type?: DataType; value?: Value; });
}
  readCapacity: number;
  writeCapacity: number;

  constructor(args?: { readCapacity?: number; writeCapacity?: number; });
}
  size: number;

  constructor(args?: { size?: number; });
}
  attribute: string;
  asc: boolean;

  constructor(args?: { attribute?: string; asc?: boolean; });
}
  indexSchema: KeySpec[];
  projections: string[];
  consistencyMode: SecondaryIndexConsistencyMode;
  unique: boolean;

  constructor(args?: { indexSchema?: KeySpec[]; projections?: string[]; consistencyMode?: SecondaryIndexConsistencyMode; unique?: boolean; });
}
  attributes: KeySpec[];
  enableHash: boolean;

  constructor(args?: { attributes?: KeySpec[]; enableHash?: boolean; });
}
  version: number;
  entityGroup: EntityGroupSpec;
  primaryIndex: KeySpec[];
  secondaryIndexes: { [k: string]: LocalSecondaryIndexSpec; };
  attributes: { [k: string]: DataType; };
  ttl: number;
  preSplits: number;

  constructor(args?: { version?: number; entityGroup?: EntityGroupSpec; primaryIndex: KeySpec[]; secondaryIndexes?: { [k: string]: LocalSecondaryIndexSpec; }; attributes?: { [k: string]: DataType; }; ttl?: number; preSplits?: number; });
}
  tableId: string;
  developerId: string;
  appAcl: { [k: string]: CannedAcl[]; };
  quota: TableQuota;
  throughput: ProvisionThroughput;
  description: string;

  constructor(args?: { tableId?: string; developerId?: string; appAcl?: { [k: string]: CannedAcl[]; }; quota?: TableQuota; throughput?: ProvisionThroughput; description?: string; });
}
  schema: TableSchema;
  metadata: TableMetadata;

  constructor(args?: { schema?: TableSchema; metadata?: TableMetadata; });
}
  state: TableState;
  createTime: number;
  alterTime: number;
  statTime: number;
  size: number;
  rowCount: number;

  constructor(args?: { state?: TableState; createTime?: number; alterTime?: number; statTime?: number; size?: number; rowCount?: number; });
}
  name: string;
  spec: TableSpec;
  status: TableStatus;

  constructor(args?: { name?: string; spec?: TableSpec; status?: TableStatus; });
}
  operator: OperatorType;
  field: string;
  value: Datum;
  rowExist: boolean;

  constructor(args?: { operator?: OperatorType; field?: string; value?: Datum; rowExist?: boolean; });
}
  startKey: { [k: string]: Datum; };
  stopKey: { [k: string]: Datum; };

  constructor(args?: { startKey?: { [k: string]: Datum; }; stopKey?: { [k: string]: Datum; }; });
}
  tableName: string;
  keys: { [k: string]: Datum; };
  attributes: string[];

  constructor(args?: { tableName?: string; keys?: { [k: string]: Datum; }; attributes?: string[]; });
}
  item: { [k: string]: Datum; };

  constructor(args?: { item?: { [k: string]: Datum; }; });
}
  tableName: string;
  record: { [k: string]: Datum; };
  condition: SimpleCondition;

  constructor(args?: { tableName?: string; record?: { [k: string]: Datum; }; condition?: SimpleCondition; });
}
  success: boolean;

  constructor(args?: { success?: boolean; });
}
  tableName: string;
  keys: { [k: string]: Datum; };
  amounts: { [k: string]: Datum; };

  constructor(args?: { tableName?: string; keys?: { [k: string]: Datum; }; amounts?: { [k: string]: Datum; }; });
}
  amounts: { [k: string]: Datum; };

  constructor(args?: { amounts?: { [k: string]: Datum; }; });
}
  tableName: string;
  keys: { [k: string]: Datum; };
  attributes: string[];
  condition: SimpleCondition;

  constructor(args?: { tableName?: string; keys?: { [k: string]: Datum; }; attributes?: string[]; condition?: SimpleCondition; });
}
  success: boolean;

  constructor(args?: { success?: boolean; });
}
  getRequest: GetRequest;
  putRequest: PutRequest;
  incrementRequest: IncrementRequest;
  removeRequest: RemoveRequest;

  constructor(args?: { getRequest?: GetRequest; putRequest?: PutRequest; incrementRequest?: IncrementRequest; removeRequest?: RemoveRequest; });
}
  action: ScanOp;
  request: Request;

  constructor(args?: { action?: ScanOp; request?: Request; });
}
  tableName: string;
  indexName: string;
  startKey: { [k: string]: Datum; };
  stopKey: { [k: string]: Datum; };
  attributes: string[];
  condition: string;
  limit: number;
  reverse: boolean;
  inGlobalOrder: boolean;
  cacheResult: boolean;
  lookAheadStep: number;
  action: ScanAction;

  constructor(args?: { tableName?: string; indexName?: string; startKey?: { [k: string]: Datum; }; stopKey?: { [k: string]: Datum; }; attributes?: string[]; condition?: string; limit?: number; reverse?: boolean; inGlobalOrder?: boolean; cacheResult?: boolean; lookAheadStep?: number; action?: ScanAction; });
}
  nextStartKey: { [k: string]: Datum; };
  records: { [k: string]: Datum; }[];
  throttled: boolean;

  constructor(args?: { nextStartKey?: { [k: string]: Datum; }; records?: { [k: string]: Datum; }[]; throttled?: boolean; });
}
  action: BatchOp;
  request: Request;

  constructor(args?: { action?: BatchOp; request?: Request; });
}
  getResult: GetResult;
  putResult: PutResult;
  incrementResult: IncrementResult;
  removeResult: RemoveResult;

  constructor(args?: { getResult?: GetResult; putResult?: PutResult; incrementResult?: IncrementResult; removeResult?: RemoveResult; });
}
  action: BatchOp;
  success: boolean;
  result: Result;
  serviceException: ServiceException;

  constructor(args?: { action?: BatchOp; success?: boolean; result?: Result; serviceException?: ServiceException; });
}
  items: BatchRequestItem[];

  constructor(args?: { items?: BatchRequestItem[]; });
}
  items: BatchResultItem[];

  constructor(args?: { items?: BatchResultItem[]; });
}
